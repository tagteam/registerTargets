#+TITLE: PhD course: Targeted Register Analysis: Day 2
#+setupfile:~/emacs-genome/snps/org-templates/setup-basic-stats-homepage.org

* Objectives

The learning targets of this exercise are:

- Writing functions in R
- Search in register data using the R-package =data.table= 
  and the R-functions =grep= and =grepl=
- Register Survival Analysis: followup time, rates versus absolute risks
- Average treatment effect: G-formula and TMLE

----------------------------------------------------------------------

* Exercise 1 


** The R-package =data.table=

For the exercises of this course we use =data.table= syntax, because
=data.table= is perfectly suited for register data: it is fast and
memory efficient. However, it is totally fine if you prefer to work
with =tidyverse/dplyr/tibble= or ordinary =data.frame=, just use
=as_tibble()= and =as.data.frame= in the sequel.

Here is the link to =data.table= introduction, tutorials
etc. https://github.com/Rdatatable/data.table and just below are
examples and use case examples of =data.table= syntax.

*** Changing data without copying

Note that whenever you use the assigment operator =<-=, e.g., to
define a new variable in a =data.frame= the whole =data.frame= is
copied internally in R. In large registry data copying takes time. The
=set.xxx= functions of =data.table= avoid copying:

#+BEGIN_SRC R  :results output raw  :exports code  :session *R* :cache yes  
library(data.table)
d <- data.frame(pnr=c(19,9,27,45,3),sex=c(1,0,0,1,0),age=c(70,86,54,66,71))
# adding a variable to a data.frame: object d is copied!
d$new_id <- 1:nrow(d)
# switch from data.frame to data.table
setDT(d)
# adding a variable to a data.table: object d is not copied!
d[,new_id:=1:nrow(d)]
# data.table shortcut: .N is the number of rows (in the current subset)
d[,new_id:=1:.N]
# data.table longcut:
set(d,j="new_id",value=1:nrow(d))
#+END_SRC

*** Sorting

In =data.table= syntax sorting of the rows of a data set is done
with the =setkey()= function.

#+BEGIN_SRC R  :results output :exports both  :session *R* :cache yes  
print(d)
#+END_SRC

:    pnr sex age new_id
: 1:  19   1  70      1
: 2:   9   0  86      2
: 3:  27   0  54      3
: 4:  45   1  66      4
: 5:   3   0  71      5

#+BEGIN_SRC R  :results output   :exports code  :session *R* :cache yes  
setkey(d,pnr)
print(d)
#+END_SRC

:    pnr sex age
: 1:   3   0  71
: 2:   9   0  86
: 3:  19   1  70
: 4:  27   0  54
: 5:  45   1  66


*** Referring to variables inside the data.table

Inside a =data.table= we can refer to the variable names
without noting the name of the data.table all the time:

#+BEGIN_SRC R  :results output raw  :exports code  :session *R* :cache yes  
# data.frame: 
sub <- d[d$age<70]
table(d[d$age<70,"sex"])
# data.table
sub <- d[age<70]
d[age<70,table(sex)]
#+END_SRC

*** Referring to variables inside a function

Inside a function or loop variables are often given as characters,
i.e., the names of the variables. 

#+BEGIN_SRC R  :results output raw  :exports code  :session *R* :cache yes  
library(data.table)
vars <- c("age","sex")
d <- data.table(pnr=c(19,9,27,45,3),sex=c(1,0,0,1,0),age=c(70,86,54,66,71))
# Tip 1:
# when setting with = FALSE data.table behaves exactly as data.frame after
# the first comma:
d[,vars,with=FALSE]
# Tip 2:
# a data.table is also a list, hence we can refer to its
# elements (the columns) using =[[]]=
d[["age"]]
d[["sex"]]
for (v in vars) d[[v]]
# Tip 3:
# argument .SDcols
d[,.SD,.SDcols=c("age","sex")]
#+END_SRC

*** Extracting the most recent value at a given date 

A common task in register data is to extract the most recent value of
a time series of data:
- at a given index year: examples as income and education
- at a given index date: examples are comorbidity, comedicine and (labka) blood test values
A convenient way to do this is called 'rolling the join' with =data.table= see
https://www.gormanalysis.com/blog/r-data-table-rolling-joins/

Here is a population with 3 subjects and their index date:

#+BEGIN_SRC R  :results output   :exports both  :session *R* :cache yes
library(data.table)
pop <- data.table(pnr=1:3,date=as.Date(c("2022-04-01","2022-08-17","2022-03-12")))
pop
#+END_SRC

#+RESULTS[(2022-12-09 16:42:59) 80d6d22d9c3b63cbc1a2bb0931df8475bfcc9abb]:
:    pnr       date
: 1:   1 2022-04-01
: 2:   2 2022-08-17
: 3:   3 2022-03-12

Here is a blood test time series

#+BEGIN_SRC R  :results output   :exports both  :session *R* :cache yes  
set.seed(9)
labka <- data.table(pnr=c(2,2,2,3,3,3,3,3,4,4),
                    date=c(as.Date("2022-08-17")-c(2138,430),as.Date("2022-03-12")-c(138,30),as.Date("2022-01-28")-48),
                    eGFR=round(rnorm(10,mean=50,sd=18)))
labka
#+END_SRC

#+RESULTS[(2022-12-09 16:48:02) 25ae440721156fa24b225c841dec48184c218033]:
#+begin_example
    pnr       date eGFR
 1:   2 2016-10-09   36
 2:   2 2021-06-13   35
 3:   2 2021-10-25   47
 4:   3 2022-02-10   45
 5:   3 2021-12-11   58
 6:   3 2016-10-09   29
 7:   3 2021-06-13   71
 8:   3 2021-10-25   50
 9:   4 2022-02-10   46
10:   4 2021-12-11   43
#+end_example

We aim to extract the latest value before the index date.
This is the result of rolling the join:

#+BEGIN_SRC R  :results output   :exports both  :session *R* :cache yes  
setkey(pop,pnr,date)
setkey(labka,pnr,date)
pop <- labka[pop,roll=TRUE]
pop
#+END_SRC

#+RESULTS[(2022-12-09 16:48:42) c6ceb82e9a299740c50a818c1f3e9e4af442e202]:
:    pnr       date eGFR
: 1:   1 2022-04-01   NA
: 2:   2 2022-08-17   47
: 3:   3 2022-03-12   45

Perhaps we only care about values that are not older than 60 days.
This is the result of rolling the join:

#+BEGIN_SRC R  :results output   :exports both  :session *R* :cache yes  
setkey(pop,pnr,date)
setkey(labka,pnr,date)
pop <- labka[pop,roll=60]
pop
#+END_SRC

#+RESULTS[(2022-12-09 16:49:34) 9f719e7f2a1a389d542234cbb34616f3d905f9e1]:
:    pnr       date eGFR
: 1:   1 2022-04-01   NA
: 2:   2 2022-08-17   NA
: 3:   3 2022-03-12   45


** Writing functions in R

In R language a function looks like this:

#+BEGIN_SRC R  :results output raw  :exports code  :session *R* :cache yes :eval never
# f is the name of the function
f <- function(arg1, # arg1 is the name of the first argument
              b,    # b is the name of the second argument
              use_this = TRUE, # use_this is the name of the third argument
                               # the default value is TRUE
              ...   # additional arguments that are passed on to other functions
              ){
  # [FUNCTION DEFINITION HERE]
}
#+END_SRC

Here is an example:

#+BEGIN_SRC R  :results output :exports both  :session *R* :cache yes  
get_pop <- function(data,age_var="age",age_limit){
  sub <- data[data[[age_var]] <= age_limit]
  sub
}
data <- data.table(pnr=c(19,9,27,45,3),sex=c(1,0,0,1,0),age=c(70,86,54,66,71))
sub70 <- get_pop(data=data,age_limit=70)
sub70
#+END_SRC

:    pnr sex age
: 1:  19   1  70
: 2:  27   0  54
: 3:  45   1  66

** The R-functions =grep= and =grepl= 

Suppose we want to extract drugs from a vector of ATC codes.

#+BEGIN_SRC R  :results output   :exports both  :session *R* :cache yes  
heaven::atccodes
#+END_SRC

#+begin_example
          ATC
   1: A01AA01
   2: A01AB02
   3: A01AB03
   4: A01AB04
   5: A01AB09
  ---        
1370: R06AX27
1371: R06AX28
1372: R06AX29
1373: R07AB01
1374: R07AB07
#+end_example

The functions =grep= and =grepl= search for matches of a /single/ (not a vector!)
search-expression in a vector. For example, we can search for "A10"

#+BEGIN_SRC R  :results output :exports both  :session *R* :cache yes  
grep("A01",heaven::atccodes$ATC)
grep("A01",heaven::atccodes$ATC,value=TRUE)
grepl("A01",heaven::atccodes$ATC)
#+END_SRC

We can use that heaven::atccodes is a data.table and subset to all
matching rows:

#+BEGIN_SRC R  :results output :exports both  :session *R* :cache yes  
heaven::atccodes[grepl("A01",heaven::atccodes$ATC)]
#+END_SRC

#+begin_example
         ATC
  1: A01AA01
  2: A01AB02
  3: A01AB03
  4: A01AB04
  5: A01AB09
 ---        
 99: N07BA01
100: N07CA01
101: R03AA01
102: R03BA01
103: R05DA01
#+end_example

Now, we only want ATC codes which start with "A01". Hence, we specify
a so-called /regular expression/:

#+BEGIN_SRC R  :results output :exports both  :session *R* :cache yes  
heaven::atccodes[grepl("^A01",heaven::atccodes$ATC)]
#+END_SRC

#+begin_example
        ATC
 1: A01AA01
 2: A01AB02
 3: A01AB03
 4: A01AB04
 5: A01AB09
 6: A01AB13
 7: A01AB17
 8: A01AB22
 9: A01AC01
10: A01AD01
11: A01AD02
12: A01AD11
#+end_example

* Exercise 2

